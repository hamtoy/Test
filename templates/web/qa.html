{% extends "layout.html" %}

{% block content %}
<div class="split-layout">
    <!-- ì™¼ìª½: OCR ì˜ì—­ -->
    <div class="left-panel">
        <h2>ğŸ“„ OCR í…ìŠ¤íŠ¸</h2>
        <textarea id="ocr-input" class="ocr-box" rows="20" placeholder="OCR í…ìŠ¤íŠ¸ë¥¼ ì§ì ‘ ì…ë ¥í•˜ì„¸ìš”..."></textarea>
        <div class="btn-row">
            <button id="save-ocr-btn" class="btn-primary" style="width: 100%;">ğŸ’¾ ì €ì¥</button>
        </div>
        <span id="ocr-save-status" class="status-text"></span>
    </div>

    <!-- ì˜¤ë¥¸ìª½: ìƒì„± ì»¨íŠ¸ë¡¤ + ê²°ê³¼ -->
    <div class="right-panel">
        <div class="control-box">
            <h2>âš™ï¸ ìƒì„± ì˜µì…˜</h2>
            
            <label for="mode-batch">
                <input type="radio" id="mode-batch" name="mode" value="batch" checked>
                4íƒ€ì… ì¼ê´„ ìƒì„±
            </label>
            
            <label for="mode-single">
                <input type="radio" id="mode-single" name="mode" value="single">
                íƒ€ì…ë³„ ìƒì„±
            </label>

            <div id="type-selector" style="display:none; margin-top: 10px;">
                <label for="qtype" style="display:block; margin-bottom: 8px;">ìƒì„± íƒ€ì…</label>
                <select id="qtype" aria-label="ìƒì„± íƒ€ì… ì„ íƒ">
                    <option value="global_explanation">ì „ë°˜ ì„¤ëª…</option>
                    <option value="reasoning">ì¶”ë¡ </option>
                    <option value="target_short">íƒ€ê²Ÿ ë‹¨ë‹µ</option>
                    <option value="target_long">íƒ€ê²Ÿ ì¥ë‹µ</option>
                </select>
            </div>

            <button id="generate-btn" class="btn-primary" style="width: 100%; margin-top: 15px;">ğŸš€ ìƒì„± ì‹¤í–‰</button>
        </div>

        <div id="results" class="results-area"></div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    // OCR ë¡œë“œ/ì €ì¥
    async function loadOCR() {
        try {
            const data = await apiCall('/api/ocr');
            document.getElementById('ocr-input').value = data.ocr || '';
        } catch (error) {
            document.getElementById('ocr-input').placeholder = 'OCR ë¡œë“œ ì‹¤íŒ¨';
        }
    }

    async function saveOCR() {
        const text = document.getElementById('ocr-input').value;
        const statusEl = document.getElementById('ocr-save-status');
        try {
            await apiCall('/api/ocr', 'POST', { text });
            statusEl.textContent = 'âœ… ì €ì¥ë¨';
            statusEl.className = 'status-text success';
            setTimeout(() => statusEl.textContent = '', 2000);
        } catch (error) {
            statusEl.textContent = 'âŒ ì €ì¥ ì‹¤íŒ¨';
            statusEl.className = 'status-text error';
        }
    }

    // ì´ˆê¸°í™”
    loadOCR();
    document.getElementById('save-ocr-btn').addEventListener('click', saveOCR);

    // ëª¨ë“œ ì„ íƒ ì‹œ íƒ€ì… ì…€ë ‰í„° í† ê¸€
    document.querySelectorAll('input[name="mode"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            const selector = document.getElementById('type-selector');
            selector.style.display = e.target.value === 'single' ? 'block' : 'none';
        });
    });

    // ìƒì„± ë²„íŠ¼
    document.getElementById('generate-btn').addEventListener('click', async () => {
        const mode = document.querySelector('input[name="mode"]:checked').value;
        const qtype = mode === 'single' ? document.getElementById('qtype').value : null;
        await generateQA(mode, qtype);
    });

    // QA ìƒì„± í•¨ìˆ˜
    async function generateQA(mode, qtype) {
        const resultsDiv = document.getElementById('results');
        const ocrText = document.getElementById('ocr-input').value;

        if (!ocrText.trim()) {
            showToast('OCR í…ìŠ¤íŠ¸ë¥¼ ë¨¼ì € ì…ë ¥í•˜ì„¸ìš”.', 'error');
            return;
        }

        // í”„ë¡œê·¸ë ˆìŠ¤ ë°” í‘œì‹œ
        resultsDiv.innerHTML = `
            <div style="text-align: center; padding: 40px; background: var(--bg-secondary, #f5f5f5); border-radius: 8px; margin-top: 20px;">
                <h3 style="margin-bottom: 15px; color: var(--text-primary, #1f2121);">${mode === 'batch' ? 'âš¡ 4ê°œ íƒ€ì… ë™ì‹œ ìƒì„± ì¤‘...' : 'ğŸš€ ë‹µë³€ ìƒì„± ì¤‘...'}</h3>
                <div style="margin: 20px auto; width: 300px; height: 12px; background: #e0e0e0; border-radius: 6px; overflow: hidden;">
                    <div class="progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #21808d, #3ba1b0); transition: width 0.3s ease;"></div>
                </div>
                <p style="margin-top: 15px; color: var(--text-secondary, #666); font-size: 0.9em;">ì˜ˆìƒ ì†Œìš” ì‹œê°„: <strong>${mode === 'batch' ? '30ì´ˆ~2ë¶„' : '15ì´ˆ~1ë¶„'}</strong></p>
                <p style="color: var(--text-secondary, #888); font-size: 0.85em;">ë³‘ë ¬ ì²˜ë¦¬ë¡œ ë¹ ë¥´ê²Œ ì™„ë£Œë©ë‹ˆë‹¤ âœ¨</p>
            </div>
        `;

        const progressBar = document.querySelector('.progress-bar');
        let progress = 0;
        const progressInterval = setInterval(() => {
            progress += 5;
            if (progress <= 90) {
                progressBar.style.width = progress + '%';
            }
        }, 200);

        try {
            const payload = { mode, ocr_text: ocrText };
            if (mode === 'single') {
                payload.qtype = qtype || 'global_explanation';
            }

            const result = await apiCall('/api/qa/generate', 'POST', payload);

            clearInterval(progressInterval);
            progressBar.style.width = '100%';
            await new Promise((resolve) => setTimeout(resolve, 300));

            displayResults(result);
        } catch (error) {
            clearInterval(progressInterval);
            resultsDiv.innerHTML = `
                <div style="text-align: center; padding: 30px; background: #ffebee; border-radius: 8px; border: 1px solid #f44336; margin-top: 20px;">
                    <h3 style="color: #f44336; margin-bottom: 10px;">âŒ ìƒì„± ì‹¤íŒ¨</h3>
                    <p style="color: #666; margin: 0;">${error.message}</p>
                </div>
            `;
        }
    }

    // ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
    function displayResults(data) {
        const resultsDiv = document.getElementById('results');
        resultsDiv.innerHTML = '';

        const pairs = data.pairs || (data.pair ? [data.pair] : []);
        if (!pairs.length) {
            resultsDiv.innerHTML = `
                <div class="qa-card">
                    <p style="margin:0; color: var(--text-secondary, #666);">ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
                </div>
            `;
            return;
        }

        pairs.forEach((item, index) => {
            const card = document.createElement('div');
            card.className = 'qa-card';
            card.style.animation = `slideIn 0.3s ease-out ${index * 0.05}s both`;

            card.innerHTML = `
                <div class="qa-header">
                    <span class="qa-type-badge">${getTypeBadge(item.type)}</span>
                </div>
                <div class="qa-section">
                    <strong>ğŸ’¬ ì§ˆì˜</strong>
                    <div class="qa-content">${escapeHtml(item.query)}</div>
                </div>
                <div class="qa-section">
                    <strong>âœ¨ ë‹µë³€</strong>
                    <div class="qa-content">${formatAnswer(item.answer)}</div>
                </div>
                <div class="btn-row" style="margin-top: 15px;">
                    <button class="btn-small qa-copy-btn">ğŸ“ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ë¡œ ë³µì‚¬</button>
                </div>
            `;

            const copyBtn = card.querySelector('.qa-copy-btn');
            copyBtn.addEventListener('click', () => {
                copyToWorkspace(item.query || '', item.answer || '');
            });

            resultsDiv.appendChild(card);
        });
    }

    function getTypeBadge(type) {
        const badges = {
            'global_explanation': 'ğŸŒ ì „ë°˜ ì„¤ëª…',
            'reasoning': 'ğŸ§  ì¶”ë¡ ',
            'target_short': 'ğŸ¯ íƒ€ê²Ÿ ë‹¨ë‹µ',
            'target_long': 'ğŸ“ íƒ€ê²Ÿ ì¥ë‹µ'
        };
        return badges[type] || type;
    }

    function formatAnswer(text) {
        const escaped = escapeHtml(text);
        const formatted = escaped
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            .replace(/\n\n/g, '<br><br>')
            .replace(/\n/g, '<br>')
            .replace(/^- /gm, 'â€¢ ');
        return DOMPurify.sanitize(formatted);
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text || '';
        return div.innerHTML;
    }

    function copyToWorkspace(query, answer) {
        sessionStorage.setItem('workspace_query', query);
        sessionStorage.setItem('workspace_answer', answer);
        window.location.href = '/workspace';
    }
</script>

<style>
    .qa-card {
        background: var(--surface, #fffffe);
        border: 1px solid var(--border, rgba(94, 82, 64, 0.12));
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .qa-header {
        margin-bottom: 15px;
    }

    .qa-type-badge {
        display: inline-block;
        padding: 6px 12px;
        background: var(--primary, #21808d);
        color: white;
        border-radius: 5px;
        font-size: 0.85em;
        font-weight: 600;
    }

    .qa-section {
        margin: 15px 0;
        padding: 12px;
        background: var(--bg-secondary, #f5f5f5);
        border-radius: 6px;
        border-left: 4px solid var(--primary, #21808d);
    }

    .qa-section strong {
        display: block;
        margin-bottom: 8px;
        color: var(--text-primary, #1f2121);
    }

    .qa-content {
        line-height: 1.6;
        color: var(--text-primary, #1f2121);
    }
</style>
{% endblock %}
