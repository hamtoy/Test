{"version":3,"file":"validation.DRcAY0lR.js","sources":["../../validation.ts"],"sourcesContent":["/**\n * API Request Validation Helper\n * \n * Provides validation functions to prevent 422 validation errors\n * by checking request payloads before sending to the backend.\n */\n\n/**\n * Validation error class\n */\nexport class ValidationError extends Error {\n    constructor(public field: string, message: string) {\n        super(`${field}: ${message}`);\n        this.name = \"ValidationError\";\n    }\n}\n\n/**\n * Required fields for /api/qa/generate endpoint\n */\ninterface GenerateQAPayload {\n    mode: \"single\" | \"batch\" | \"batch_three\";\n    ocr_text?: string;\n    qtype?: string;\n    batch_types?: string[];\n}\n\n/**\n * Required fields for /api/workspace/unified endpoint\n */\ninterface UnifiedWorkspacePayload {\n    mode?: string;\n    query?: string | null;\n    answer?: string | null;\n    edit_request?: string | null;\n    ocr_text?: string | null;\n    query_type?: string | null;\n    global_explanation_ref?: string | null;\n}\n\n/**\n * Validate GenerateQA request payload\n * \n * @param data Request payload to validate\n * @throws ValidationError if validation fails\n */\nexport function validateGenerateQARequest(data: unknown): asserts data is GenerateQAPayload {\n    if (!data || typeof data !== \"object\") {\n        throw new ValidationError(\"payload\", \"요청 데이터가 객체여야 합니다\");\n    }\n\n    const payload = data as Record<string, unknown>;\n\n    // Validate mode\n    if (!payload.mode || typeof payload.mode !== \"string\") {\n        throw new ValidationError(\"mode\", \"필수 필드 누락 또는 타입 오류 (문자열 필요)\");\n    }\n\n    const validModes = [\"single\", \"batch\", \"batch_three\"];\n    if (!validModes.includes(payload.mode)) {\n        throw new ValidationError(\n            \"mode\",\n            `유효하지 않은 값: \"${payload.mode}\". 가능한 값: ${validModes.join(\", \")}`\n        );\n    }\n\n    // Validate ocr_text (optional, but must be string if provided)\n    if (payload.ocr_text !== undefined && payload.ocr_text !== null) {\n        if (typeof payload.ocr_text !== \"string\") {\n            throw new ValidationError(\"ocr_text\", \"문자열이어야 합니다\");\n        }\n    }\n\n    // Validate qtype for single mode\n    if (payload.mode === \"single\") {\n        if (!payload.qtype || typeof payload.qtype !== \"string\") {\n            throw new ValidationError(\n                \"qtype\",\n                \"single 모드에서는 qtype이 필수입니다 (문자열)\"\n            );\n        }\n\n        // Accept both exact Pydantic values and common aliases that backend normalizes\n        const validQTypes = [\n            \"global_explanation\",\n            \"globalexplanation\",  // Alias for global_explanation\n            \"reasoning\",\n            \"target_short\",\n            \"target_long\",\n            \"target\",  // Alias accepted by backend\n        ];\n        if (!validQTypes.includes(payload.qtype)) {\n            throw new ValidationError(\n                \"qtype\",\n                `유효하지 않은 값: \"${payload.qtype}\". 가능한 값: ${validQTypes.slice(0, 5).join(\", \")}`\n            );\n        }\n    }\n\n    // Validate batch_types (optional array)\n    if (payload.batch_types !== undefined && payload.batch_types !== null) {\n        if (!Array.isArray(payload.batch_types)) {\n            throw new ValidationError(\"batch_types\", \"배열이어야 합니다\");\n        }\n\n        for (let i = 0; i < payload.batch_types.length; i++) {\n            if (typeof payload.batch_types[i] !== \"string\") {\n                throw new ValidationError(\n                    `batch_types[${i}]`,\n                    \"모든 요소가 문자열이어야 합니다\"\n                );\n            }\n        }\n    }\n}\n\n/**\n * Validate UnifiedWorkspace request payload\n * \n * @param data Request payload to validate\n * @throws ValidationError if validation fails\n */\nexport function validateUnifiedWorkspaceRequest(data: unknown): asserts data is UnifiedWorkspacePayload {\n    if (!data || typeof data !== \"object\") {\n        throw new ValidationError(\"payload\", \"요청 데이터가 객체여야 합니다\");\n    }\n\n    const payload = data as Record<string, unknown>;\n\n    // All fields are optional but must have correct types if provided\n    const stringFields = [\"mode\", \"query\", \"answer\", \"edit_request\", \"ocr_text\", \"query_type\", \"global_explanation_ref\"];\n\n    for (const field of stringFields) {\n        const value = payload[field];\n        if (value !== undefined && value !== null && typeof value !== \"string\") {\n            throw new ValidationError(field, `문자열이어야 합니다. 받은 타입: ${typeof value}`);\n        }\n    }\n\n    // Validate query_type values if provided\n    if (payload.query_type && typeof payload.query_type === \"string\") {\n        // Accept both exact Pydantic values and common aliases\n        const validQTypes = [\n            \"global_explanation\",\n            \"globalexplanation\",  // Alias\n            \"reasoning\",\n            \"target_short\",\n            \"target_long\",\n            \"target\",  // Alias\n        ];\n        if (!validQTypes.includes(payload.query_type)) {\n            throw new ValidationError(\n                \"query_type\",\n                `유효하지 않은 값: \"${payload.query_type}\". 가능한 값: ${validQTypes.slice(0, 5).join(\", \")}`\n            );\n        }\n    }\n}\n\n/**\n * Check for common field name errors (camelCase vs snake_case)\n * \n * @param data Request payload to check\n * @returns Array of warnings about potential field name issues\n */\nexport function checkFieldNames(data: unknown): string[] {\n    if (!data || typeof data !== \"object\") {\n        return [];\n    }\n\n    const warnings: string[] = [];\n    const payload = data as Record<string, unknown>;\n\n    // Common mistakes: camelCase instead of snake_case\n    const incorrectFields: Record<string, string> = {\n        \"ocrText\": \"ocr_text\",\n        \"queryType\": \"query_type\",\n        \"editRequest\": \"edit_request\",\n        \"batchTypes\": \"batch_types\",\n        \"globalExplanationRef\": \"global_explanation_ref\",\n    };\n\n    for (const [incorrect, correct] of Object.entries(incorrectFields)) {\n        if (incorrect in payload) {\n            warnings.push(\n                `⚠️ 필드명 오타: \"${incorrect}\" → 올바른 필드명: \"${correct}\" (snake_case 사용)`\n            );\n        }\n    }\n\n    return warnings;\n}\n\n/**\n * Normalize and validate request data before API call\n * \n * @param data Request payload\n * @param endpoint API endpoint being called\n * @throws ValidationError if validation fails\n */\nexport function validateRequest(data: unknown, endpoint: string): void {\n    // Check for field name issues first\n    const warnings = checkFieldNames(data);\n    if (warnings.length > 0) {\n        throw new ValidationError(\"field_names\", warnings.join(\"\\n\"));\n    }\n\n    // Validate based on endpoint\n    if (endpoint.includes(\"/api/qa/generate\")) {\n        validateGenerateQARequest(data);\n    } else if (endpoint.includes(\"/api/workspace/unified\")) {\n        validateUnifiedWorkspaceRequest(data);\n    }\n}\n\n/**\n * Parse 422 validation error response from backend\n * \n * @param errorData Error response from backend\n * @returns Human-readable error message\n */\nexport function parse422Error(errorData: unknown): string {\n    if (!errorData || typeof errorData !== \"object\") {\n        return \"요청 데이터 검증 실패\";\n    }\n\n    const data = errorData as Record<string, unknown>;\n\n    // FastAPI validation error format\n    if (Array.isArray(data.detail)) {\n        const errors = data.detail as Array<{\n            loc?: string[];\n            msg?: string;\n            type?: string;\n        }>;\n\n        const messages = errors.map((err) => {\n            const field = err.loc?.slice(1).join(\".\") || \"unknown\";\n            const message = err.msg || \"validation error\";\n            return `• ${field}: ${message}`;\n        });\n\n        return `요청 데이터 검증 실패:\\n${messages.join(\"\\n\")}`;\n    }\n\n    // Fallback\n    if (typeof data.detail === \"string\") {\n        return data.detail;\n    }\n\n    return \"요청 데이터 검증 실패\";\n}\n"],"names":["ValidationError","field","message","validateGenerateQARequest","data","payload","validModes","validQTypes","i","validateUnifiedWorkspaceRequest","stringFields","value","checkFieldNames","warnings","incorrectFields","incorrect","correct","validateRequest","endpoint","parse422Error","errorData","err"],"mappings":"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"}